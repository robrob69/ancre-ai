"""
Calendar Intent Service.

Parses user natural language requests into structured CalendarCommand.
Uses Mistral LLM to understand intent, resolve temporal expressions,
and detect ambiguities requiring clarification.
"""

from datetime import datetime, timezone as dt_timezone
from typing import Optional, List
from uuid import UUID
import json
import logging

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.calendar import NangoConnection
from app.schemas.calendar import (
    CalendarCommand,
    CalendarParseResponse,
    ClarificationQuestion,
    CalendarProvider,
    CalendarOperationType,
    ClarificationReason,
)
from app.config import get_settings

settings = get_settings()
logger = logging.getLogger(__name__)


CALENDAR_PARSING_SYSTEM_PROMPT = """Tu es un assistant calendrier expert. Analyse la demande de l'utilisateur et extrais une commande structurée.

CONTEXTE ACTUEL:
- Date/heure: {now} (timezone: {timezone})
- Providers disponibles: {providers}
- Provider cible: {target_provider}

RÈGLES STRICTES:
1. Expressions temporelles relatives ("demain", "lundi prochain", "ce soir", "dans 2h") → calculer date/heure précise
2. Durée par défaut: 30 minutes si non spécifiée
3. Titre obligatoire: si absent, générer "Rendez-vous" et marquer title_autogenerated=true
4. Participants: extraire UNIQUEMENT les emails explicites (format: xxx@yyy.zzz). NE JAMAIS inventer d'emails
5. Visio: mots-clés "visio", "vidéo", "meet", "teams", "zoom" → add_video_conference=true
6. Delete: TOUJOURS requires_confirmation=true sauf si "supprime définitivement" ou "delete permanently"
7. Si ambiguïté détectée → needs_clarification=true avec raison claire

ACTIONS SUPPORTÉES:
- create: créer un nouvel événement
- update: modifier un événement existant (nécessite identification)
- delete: supprimer un événement (nécessite confirmation)
- list: lister les événements sur une plage
- find: rechercher un événement par critères

DISAMBIGUATION:
Si plusieurs interprétations possibles:
- Multiple events matchent → clarification avec options
- Provider non déterminé (si plusieurs) → demander choix
- Heure ambiguë ("à 2h" = 2h du matin ou 14h?) → clarifier
- Info manquante critique (titre pour create, date pour update) → demander

OUTPUT FORMAT (JSON strict):
{{
  "needs_clarification": false,
  "command": {{
    "action": "create|update|delete|list|find",
    "title": "Titre exact",
    "title_autogenerated": false,
    "starts_at": "2026-02-20T14:00:00+01:00",  // ISO 8601 avec timezone
    "ends_at": "2026-02-20T14:30:00+01:00",
    "timezone": "{timezone}",
    "attendees": ["email@example.com"],  // Seulement si explicite
    "description": "Description si fournie",
    "add_video_conference": false,
    "requires_confirmation": false,
    "confidence_score": 0.95  // 0-1, reflète ton niveau de certitude
  }}
}}

SI CLARIFICATION NÉCESSAIRE:
{{
  "needs_clarification": true,
  "clarification_reason": "multiple_events|multiple_providers|missing_information|ambiguous_time",
  "clarification_message": "Question claire et concise pour l'utilisateur",
  "show_calendar_modal": true,  // Si pertinent de montrer le calendrier visuel
  "options": [  // Optionnel: choix multiples
    {{"label": "Option 1 claire", "value": "valeur_technique"}},
    {{"label": "Option 2 claire", "value": "valeur_technique"}}
  ],
  "partial_command": {{...}}  // Commande partielle avec les infos déjà extraites
}}

EXEMPLES:

User: "Ajoute une visio avec Marie demain à 14h"
→ {{"needs_clarification": false, "command": {{"action": "create", "title": "Visio avec Marie", "starts_at": "2026-02-17T14:00:00+01:00", "ends_at": "2026-02-17T14:30:00+01:00", "add_video_conference": true, "confidence_score": 0.95}}}}

User: "Décale ma réunion de demain"
→ {{"needs_clarification": true, "clarification_reason": "missing_information", "clarification_message": "À quelle heure veux-tu déplacer cette réunion ?", "show_calendar_modal": true}}

User: "Supprime mon appel"
→ {{"needs_clarification": true, "clarification_reason": "multiple_events", "clarification_message": "Quel appel veux-tu supprimer ? (J'en ai trouvé plusieurs)", "show_calendar_modal": true}}

IMPORTANT: Réponds UNIQUEMENT avec le JSON, sans texte additionnel."""


class CalendarIntentService:
    """Service to parse calendar intents from natural language"""

    def __init__(self, db: AsyncSession, current_user: dict):
        self.db = db
        self.tenant_id = current_user["tenant_id"]
        self.user_id = current_user["user_id"]

    async def parse_intent(
        self,
        text: str,
        timezone: str,
        now_iso: Optional[str] = None,
        assistant_id: Optional[UUID] = None,
        provider_preference: Optional[CalendarProvider] = None,
    ) -> CalendarParseResponse:
        """
        Parse user text into CalendarCommand or Clarification.

        Args:
            text: User's natural language request
            timezone: User's timezone (e.g., "Europe/Paris")
            now_iso: Current datetime in ISO format (optional, defaults to now)
            assistant_id: Assistant ID if triggered from assistant context
            provider_preference: Preferred provider if user specified

        Returns:
            CalendarParseResponse with either command or clarification
        """
        try:
            # 1. Get available providers
            available_providers = await self._get_available_providers()

            if not available_providers:
                return CalendarParseResponse(
                    success=False,
                    error="Aucun calendrier connecté. Veuillez connecter Google Calendar ou Outlook dans votre profil.",
                )

            # 2. Determine target provider
            target_provider = self._select_provider(available_providers, provider_preference)

            # 3. Parse current time
            if now_iso:
                now = datetime.fromisoformat(now_iso)
            else:
                # Use timezone-aware now
                import zoneinfo
                tz = zoneinfo.ZoneInfo(timezone)
                now = datetime.now(tz)

            # 4. Call LLM to parse intent
            llm_response = await self._call_llm_parser(
                text=text,
                now=now,
                timezone=timezone,
                available_providers=available_providers,
                target_provider=target_provider,
            )

            # 5. Process LLM response
            if llm_response.get("needs_clarification"):
                clarification = ClarificationQuestion(
                    reason=ClarificationReason(llm_response["clarification_reason"]),
                    message=llm_response["clarification_message"],
                    options=llm_response.get("options"),
                    show_calendar_modal=llm_response.get("show_calendar_modal", False),
                    partial_command=CalendarCommand(**llm_response["partial_command"])
                    if llm_response.get("partial_command")
                    else None,
                )
                return CalendarParseResponse(success=True, clarification=clarification)

            # 6. Build command
            command_data = llm_response["command"]
            command_data["provider"] = target_provider.value if target_provider else None

            command = CalendarCommand(**command_data)

            return CalendarParseResponse(success=True, command=command)

        except Exception as e:
            logger.error(f"Error parsing calendar intent: {e}", exc_info=True)
            return CalendarParseResponse(
                success=False, error=f"Erreur lors de l'analyse de votre demande: {str(e)}"
            )

    async def _get_available_providers(self) -> List[CalendarProvider]:
        """Get list of connected calendar providers for this user"""
        stmt = select(NangoConnection).where(
            NangoConnection.tenant_id == self.tenant_id,
            NangoConnection.user_id == self.user_id,
            NangoConnection.is_active == True,
            NangoConnection.provider.in_(["google_calendar", "microsoft_calendar"]),
        )
        result = await self.db.execute(stmt)
        connections = result.scalars().all()

        providers = []
        for conn in connections:
            if "google" in conn.provider.lower():
                providers.append(CalendarProvider.GOOGLE)
            elif "microsoft" in conn.provider.lower():
                providers.append(CalendarProvider.MICROSOFT)

        return providers

    def _select_provider(
        self,
        available: List[CalendarProvider],
        preference: Optional[CalendarProvider],
    ) -> Optional[CalendarProvider]:
        """
        Select which provider to use.

        Priority:
        1. User preference (if valid)
        2. Only one available → auto-select
        3. Multiple available → None (will need clarification)
        """
        if preference and preference in available:
            return preference

        if len(available) == 1:
            return available[0]

        return None  # Multiple providers, needs clarification

    async def _call_llm_parser(
        self,
        text: str,
        now: datetime,
        timezone: str,
        available_providers: List[CalendarProvider],
        target_provider: Optional[CalendarProvider],
    ) -> dict:
        """
        Call Mistral LLM to parse the calendar intent.

        Uses structured output (JSON mode) for reliable parsing.
        """
        # Import here to avoid circular dependency
        from app.services.llm import get_llm_client

        llm_client = get_llm_client()

        providers_str = ", ".join(p.value for p in available_providers)
        target_str = target_provider.value if target_provider else "à déterminer"

        system_prompt = CALENDAR_PARSING_SYSTEM_PROMPT.format(
            now=now.isoformat(),
            timezone=timezone,
            providers=providers_str,
            target_provider=target_str,
        )

        user_message = f"Demande utilisateur: {text}"

        try:
            response = await llm_client.chat_completion(
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_message},
                ],
                model=settings.LLM_MODEL,
                temperature=0.1,  # Low temperature for consistent parsing
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content
            parsed = json.loads(content)

            logger.info(f"LLM parsed intent: {parsed}")

            return parsed

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse LLM JSON response: {e}")
            # Fallback: assume clarification needed
            return {
                "needs_clarification": True,
                "clarification_reason": "missing_information",
                "clarification_message": "Désolé, je n'ai pas bien compris votre demande. Pouvez-vous reformuler ?",
            }
        except Exception as e:
            logger.error(f"LLM call failed: {e}", exc_info=True)
            raise
