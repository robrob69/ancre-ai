"""
Pydantic schemas for calendar API.

Defines request/response models for:
- Calendar command parsing
- Event execution
- Provider management
- Event listing and search
"""

from datetime import datetime
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, Field, field_validator
from uuid import UUID


# ========== Enums ==========

class CalendarProvider(str, Enum):
    """Supported calendar providers"""
    GOOGLE = "google"
    MICROSOFT = "microsoft"


class CalendarOperationType(str, Enum):
    """Types of calendar operations"""
    CREATE = "create"
    UPDATE = "update"
    DELETE = "delete"
    LIST = "list"
    FIND = "find"


class ClarificationReason(str, Enum):
    """Reasons why clarification is needed"""
    MULTIPLE_EVENTS = "multiple_events"
    MULTIPLE_PROVIDERS = "multiple_providers"
    MISSING_INFORMATION = "missing_information"
    AMBIGUOUS_TIME = "ambiguous_time"


# ========== Commands ==========

class CalendarCommand(BaseModel):
    """
    Structured calendar command parsed from user text.

    Used internally to execute calendar operations.
    """
    action: CalendarOperationType
    provider: Optional[CalendarProvider] = None

    # Create/Update fields
    title: Optional[str] = None
    title_autogenerated: bool = False
    starts_at: Optional[datetime] = None
    ends_at: Optional[datetime] = None
    timezone: str = "Europe/Paris"
    attendees: List[str] = Field(default_factory=list)
    description: Optional[str] = None
    add_video_conference: bool = False

    # Update/Delete fields
    event_id: Optional[str] = None  # external_event_id
    search_title: Optional[str] = None
    search_range_start: Optional[datetime] = None
    search_range_end: Optional[datetime] = None

    # List/Find fields
    range_start: Optional[datetime] = None
    range_end: Optional[datetime] = None
    query: Optional[str] = None

    # Meta
    requires_confirmation: bool = False
    confidence_score: float = Field(default=1.0, ge=0, le=1)

    class Config:
        json_schema_extra = {
            "example": {
                "action": "create",
                "provider": "google",
                "title": "Réunion avec Marie",
                "starts_at": "2026-02-20T14:00:00+01:00",
                "ends_at": "2026-02-20T14:30:00+01:00",
                "timezone": "Europe/Paris",
                "add_video_conference": True,
                "requires_confirmation": False,
                "confidence_score": 0.95
            }
        }


class ClarificationQuestion(BaseModel):
    """
    Question to ask user when intent is ambiguous.

    Can optionally show calendar modal for visual selection.
    """
    reason: ClarificationReason
    message: str
    options: Optional[List[dict]] = None  # [{"label": "...", "value": "..."}]
    show_calendar_modal: bool = False
    partial_command: Optional[CalendarCommand] = None

    class Config:
        json_schema_extra = {
            "example": {
                "reason": "multiple_events",
                "message": "J'ai trouvé 3 réunions demain. Laquelle veux-tu déplacer ?",
                "options": [
                    {"label": "Standup - 09:00", "value": "evt_1"},
                    {"label": "Appel client - 10:30", "value": "evt_2"}
                ],
                "show_calendar_modal": True
            }
        }


class CalendarParseRequest(BaseModel):
    """Request to parse user text into calendar command"""
    text: str = Field(..., min_length=1, description="User's calendar request in natural language")
    timezone: str = Field(default="Europe/Paris", description="User's timezone")
    now_iso: Optional[str] = Field(None, description="Current datetime in ISO 8601 format")
    assistant_id: Optional[UUID] = Field(None, description="Assistant ID if triggered from assistant")
    provider_preference: Optional[CalendarProvider] = Field(None, description="Preferred provider if multiple")

    class Config:
        json_schema_extra = {
            "example": {
                "text": "Ajoute une visio avec Paul demain à 14h",
                "timezone": "Europe/Paris",
                "assistant_id": None,
                "provider_preference": "google"
            }
        }


class CalendarParseResponse(BaseModel):
    """Response from parsing user text"""
    success: bool
    command: Optional[CalendarCommand] = None
    clarification: Optional[ClarificationQuestion] = None
    error: Optional[str] = None


# ========== Execution ==========

class CalendarExecuteRequest(BaseModel):
    """Request to execute a calendar command"""
    command: CalendarCommand
    assistant_id: Optional[UUID] = None
    skip_confirmation: bool = False


class EventSummary(BaseModel):
    """
    Summary of a calendar event.

    Returned after create/update/list operations.
    """
    id: str  # external_event_id
    title: str
    starts_at: datetime
    ends_at: datetime
    timezone: str
    provider: CalendarProvider
    calendar_id: str = "primary"
    attendees: List[str] = Field(default_factory=list)
    video_conference_link: Optional[str] = None
    html_link: Optional[str] = None  # Link to open in Google/Outlook
    description: Optional[str] = None

    class Config:
        json_schema_extra = {
            "example": {
                "id": "google_evt_123abc",
                "title": "Réunion avec Marie",
                "starts_at": "2026-02-20T14:00:00+01:00",
                "ends_at": "2026-02-20T14:30:00+01:00",
                "timezone": "Europe/Paris",
                "provider": "google",
                "calendar_id": "primary",
                "attendees": ["marie@example.com"],
                "video_conference_link": "https://meet.google.com/xxx-yyyy-zzz",
                "html_link": "https://calendar.google.com/event?eid=..."
            }
        }


class CalendarResult(BaseModel):
    """Result of executing a calendar operation"""
    success: bool
    operation: CalendarOperationType
    provider: Optional[CalendarProvider] = None
    event: Optional[EventSummary] = None
    events: List[EventSummary] = Field(default_factory=list)  # For list/find
    message: str
    error: Optional[str] = None


# ========== Providers ==========

class ProviderInfo(BaseModel):
    """Information about a connected calendar provider"""
    provider: CalendarProvider
    nango_connection_id: str
    is_active: bool
    user_email: Optional[str] = None
    connected_at: datetime


class ProvidersListResponse(BaseModel):
    """List of connected calendar providers"""
    providers: List[ProviderInfo]
    has_google: bool = False
    has_microsoft: bool = False


# ========== Events List ==========

class CalendarEventsRequest(BaseModel):
    """Query parameters for listing events"""
    range_start: datetime
    range_end: datetime
    provider: Optional[CalendarProvider] = None
    query: Optional[str] = None


class CalendarEventsResponse(BaseModel):
    """Response with list of calendar events"""
    events: List[EventSummary]
    range_start: datetime
    range_end: datetime
    providers_queried: List[CalendarProvider]


# ========== Availability (optional, for phase 2) ==========

class BusySlot(BaseModel):
    """A busy time slot"""
    starts_at: datetime
    ends_at: datetime
    event_title: Optional[str] = None


class FreeSlot(BaseModel):
    """A free time slot"""
    starts_at: datetime
    ends_at: datetime
    score: float = Field(default=1.0, ge=0, le=1, description="Quality score (morning > afternoon, etc.)")


class AvailabilityRequest(BaseModel):
    """Request to find available slots"""
    range_start: datetime
    range_end: datetime
    provider: Optional[CalendarProvider] = None
    slot_duration_minutes: int = Field(default=30, ge=15, le=480)


class AvailabilityResponse(BaseModel):
    """Response with busy and free slots"""
    busy_slots: List[BusySlot]
    free_slots: List[FreeSlot]
    range_start: datetime
    range_end: datetime
